<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[dsuisdfousdiofds,fdsfdsfdsker, rewruewrowere. rewuroewr. dfdsfdseow, fdsklfds. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员中的梦想家]]></title>
    <url>%2F2019%2F07%2F04%2F2018-06-30-dreamer%2F</url>
    <content type="text"><![CDATA[本文首发于我的知乎专栏 The Little Programmer，转载请保留链接 ;) 有一类程序员是 visionary 型的，为了实现一些超前的 idea，绕过某些技术的限制，他们写的 code 晦涩高深得只有他们自己能懂，做出来的 tool 看上去很美好结果处处是坑出了 bug 根本没法查，但正是这类人不断创造出新的东西，在洗礼之后成为一个个 big thing。 我每周都要被 infra 的坑 block 得无法工作几次搞得非常沮丧，后来我发现这个锅除了要扔给 FB 外，还有一大半要扔给我周围这群 visionary 的同事们，我工作直接需要接触到的区区五六个人，发起/创造了 Infer, React, Reason, ReasonReact, BuckleScript… 所以这大概就是见证/参与这些 idea 成长的代价吧，也意识到这些东西不是在刚开始就像后来大家接受流行时那么美好的。React 发布 5 周年生日时回放 Jordan/Tom 2013 年第一次对外发布 React/JSX 的视频。我问 Jordan 说你后来怎么没再去分享了。他说你不知道我那天讲完下来被所有听众指着批评。React 第一次在内部使用是 2011 年在 news feed，然后是 2012 年 instagram (pete hunt)，所以这个时间其实很长很长。 很多人（包括我）都会经常觉得 XYZ 新事物跟老东西比太新、太不成熟、体验太不好、想要解决的问题太多、解决方案太 overkill、然后就没有然后了，但其实说不定你在看的这个就是 next big thing 呢。这些梦想家们 vision 里的 big picture 太大了，有的人可能在半个 picture 出来的时候就可以看出来了，有的人则可能要等到整个 picture 都快填满了才看得出来。 如果不是因为 Ads/Messenger 的坑深 React/Reason/Flux 也就不会在这里诞生了， 如果不是因为 Facebook 的坑深 GraphQL/Infer/Hack/Flow/Buck 也就不会在这里诞生了。 正是有一群开垦者不怕坑深才使得各种 idea 成为了大家手上好用的 tool 啊。 梦想家程序员们的工作价值于实干主义的程序员，总是很容易在过程中被低估、忽视，或是得不到尊重。而又在流行之后被神化，仿佛是那个人早已洞察一切一样。其实梦想家的工作，也是一点点累加，一点点迭代起来的。他们也需要伯乐和追随者的支持和帮助。 Chenglou 这个人总是在巨兴奋与巨沮丧之间切换，这段时间下来，我开始能感受这种情绪的来源了。 他总是用一句话来总结他回答我的吐槽、抱怨、疑问、惊叹，我就用这句话来结尾好了： “Welcome to the producer side!”]]></content>
      <tags>
        <tag>Facebook</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Avoiding success at all cost]]></title>
    <url>%2F2019%2F07%2F04%2F2018-09-27-avoiding-success-at-all-cost%2F</url>
    <content type="text"><![CDATA[“Avoiding success at all cost” is the informal motto behinds Haskell. It could be parenthesized in two ways, either “Avoiding (success at all cost)” or “(Avoiding sucess) (at all cost)”. I’m not going to interpret them directly but rather to share some thoughts on “the success vs. costs” basing on my very own understanding and experience. The success vs. cost of language designThere’re always trade offs (or compromises) in any software design, and programming language design has no exceptions. In other words, all language design decision that made them “successful” i.e. being popular and widely-used in industry or education for some reasons, all comes with their own “costs”: being unsafe, limited expressiveness, or having bad performance, etc. Whether or not the “cost” is a problem really depends on scenarios, or their goals. For instances, Python/JavaScript are both very expressive and beginner-friendly by being dynamically-typed, sacrifing the type safety and performance. Java, in constrast, uses a much safer and optimization-friendly type system but being much less expressive. Another typicial comparison would be memory management in programming languages, where languages that are “managed” (by either ARC or Gabage Collector) could be much easier and safer (in terms of memory) for most programmers but also considerred slower than languages that are “closer to the metal”. None of these “costs”, or “differences”, really prevent them from being immortally popular. For Haskell, the story becomes quite different: being research-oriented means the goal of this language is to pursue some “ultimate” things: the “ultimate” simplicity of intermediate representation, the “ultimate” type system where safety and expressiveness can coexist, the “ultimate” compilation speed and runtime performance, the “ultimate” concise and elegant concrete syntax, the “ultimate”…I don’t know. But it has to be some “ultimate” things that is very difficult, probably endless and impossible, to achieve. This, as a result, made all language decisions in Haskell became very hard and slow, because almost nothing can be scarified. That’s why Haskell insisted to be lazy to “guard” the purity regardless of some problems of being “call-by-need”; a decent IO mechanisms is missing in the first 4 yrs after the project’s start until P Walder found Monad; and the Type Class, which is first proposed in P Walder’s 1989 paper, spent yrs long to implement and popularize. As a side note though, it doesn’t mean there is no compromise in Haskell at all. It’s just as minimized as it could be during its progress. When one audience asking why we have Haskell and OCaml, which’re quite similar in very high level, both survived, SPJ replies: There’s just a different set of compromises. The success vs. cost of language design processAnother common but extremely controversial (if not the most) topics of programming language design is about its design process: Would you prefer dictatorship or a committee (in other words, a dictatorship of many?)? Would you prefer being proprietary or standardized? In which form would you write the standards, in human nature language, pseudo code, or formal semantics? How many and how frequently breaking changes dare you make? Would you let open source community involve in? Again, I think there is no THE answer for all those questions. Majority of popular programming languages came and are still on going with very different paths. Python, whose creater, Guido van Rossum, known as the “Benevolent Dictator For Life” (BDFL), i.e. good kind of dictator, still play the central role (until July 2018) of the Python’s development after Python getting popular and adapt a open source and community-based development model. This factor direcly contribute to the fact that Python 3, as a breaking (not completely backward-compatible and not easy to port) but good (in terms of language design and consistency) revision of the language can still be landed, despite of many communities’ pressures. There’re many language (Ruby, Perl, Elm) also choose to follow this route. JavaScript, widely known as being created by Brendan Eich in 10 days, in comparision, quickly involved into a committee (TC39) and standardized (ECMAScript) language due to both the open nature of the Web and fast adoption of itself. But Brendan, as the creater, wasn’t even powerful enough to push the committee landing ES4, which is also a breaking but much better revision, but ended up with the ES5 (Harmony), a backward-compatible, yet much less ambitious version due to many political “fights” between different parties (e.g. Mozilla, Microsoft, Yahoo etc.) thus the history wasn’t changed. Even the latest rising and yearly releasing of the “modern” JavaScript (ES6 or ES2015, 2016, 2017…) are mainly driven by the new generation of committee parties (+ Google, Facebook, Airbnb etc.) and still in a very open and standardized way. As you can see here, even the history and progress of two rather similar languages can be so different, not to mention more proprietary languages such as Java from Sun/Oracle, C# from Microsoft, OC/Swift from Apple (though the latter was open sourced) or more academia and standardized language like SML and Scheme which both has a standard written in formal semantics. So it’s not not obvious that Haskell, also chose its own unique process to suit its unique goal. Although it backs on academia, it chose a rather practical/less-formal approach to define the language, i.e. the compiler implementation over standardization (plus many “formal” fragments among papers though), which is more like C++/OCaml from this point of view. It has a committee, but instead of being very open and conservative, it’s more dictatorial (in terms of average users) and super aggressive in terms of making breaking changes. As a result however, it trained a group of very change-tolerant people in its community…All of these quirks and odds combined works very well and avoid the Haskell “becoming too success too quickly”. End thoughtsTo be fair, Haskell has alreay been very “successful” nowdays, in particular academia (for education, sexy type laboratory etc.) but also industry, either being used in real business or being very reputable among programmers (as being both hard and fun). I am not confident and qualified to say Haskell is success in the right degree at the right time. But it’s great to see it, after more than 20 and now almost 30 yrs, slowly figure out its very own way, to “Escape from the Ivory Tower”, and keep going beyond.]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>PL</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗马数字（上）——拼写规则]]></title>
    <url>%2F2019%2F06%2F26%2F%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94%E6%8B%BC%E5%86%99%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[罗马数字符号罗马数字是总共由 7 个字母符号表示：I（1）、V（5）、X（10）、L（50）、C（100）、D（500）和 M（1000）。 表一：罗马数字对应的阿拉伯数字 罗马数字 阿拉伯数字 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 他们按照以下 4 个规则可以组合成表示任意的正整数。 规则 1一个罗马数字重复多少次，就表示这个数多少倍，比如罗马数字 I 表示的是数字 1，重复两次，即 II，表示的数字是 2，同理，III 表示数字 3，XX 表示数字 20，CC 表示数字 200 等； 需要注意的是，同一个罗马数字最多只能连续重复 3 次，如数字 400 就不能表示为 CCCC（重复了 4 次），而是要用 CD 来表示，数字40不能表示为 XXXX（同样重复了 4 次），而要表示为 XL 等。 但有一种特殊情况，因为古罗马人用 IV 作为古罗马神话主神朱庇特（IVPITER，古罗马字母里没有 J 和 U）名字的简写，他们不希望神的名字看上去像个数字，因此有时用 IIII 代替 IV。 另外，符号 D、L 和 V 不可以连续重复出现，比如用 DD 表示 1000 的写法是错误的，正确的是要用 M，表示 1500 的罗马数字是 MD，而不是 DDD。 规则 2如果在较大的罗马数字后面（右边）放置较小的罗马数字，表示的数字为这些数字相加得到的数，如较大的罗马数字 V 后面放置较小的罗马数字 I，即 VI，表示的数字则为 V 与 I 相加得到数 6。 同理，VII = 7 (5 + 2 = 7)LXXX = 80 (50 + 10 + 10 + 10 = 80)MC = 1100 (1000 + 100 = 1100) 规则 3如果在较大的罗马数字前面（左边）放置在较小的罗马数字，表示的数是用较大的数减去较小的数所得到的值，如较大的罗马数字 V 前面或左边放置较小的罗马数字 I，即 IV，表示的数字则为 V 减去 I 得到的数 4。 同理，IX = 9 (10 – 1 = 9)XC = 90 (100 – 10 = 90) 用这种方式来表示罗马数字时，有以下几点需要注意： i) 充当减数的只能是 I，C 或 X，不能是 L 或 V，即罗马数字对应的数是 10 的 n 次幂才能充当减数。另外，由于 M 在罗马字母中表示的数最大，也不能充当减数（罗马数字没有 0 或负整数）。 被减数 - 减数 = 差，如 32 - 10 = 22，被减数是 32，减数是 10，差是 22。 表二：被减数的只能是 I，C 或 X 罗马数字 阿拉伯数字 10 的 n 次幂 说明 I 1 $10^0 = 1$ 10的0次幂 X 10 $10^1 = 10$ 10的1次幂 C 100 $10^2 = 100$ 10的2次幂 比如数字 45，不能写成 VL（50 - 5），而是要写成 XLV（XL + V，即 40 + 5）； ii) 只能从一个罗马数字中减去另一个罗马数字，而不能减去两个或两个以上的罗马数字，比如说数字 8，不能写成 IIX（X - I - I，即 10 - 1 - 1 = 8），而是要写成 VIII（V + I + I + I，即 5 + 1 + 1 + 1 = 8）； iii) 从一个罗马数字（设为 a）中减去另一个罗马数字（设为 b）所得的差（设为 c），不能超过减数（即 b）的 10 倍以上。例如，你可以从数字 10 中减去 1，因为 10 - 1 = 9，9 比 1 的 10 倍（10）小；但是不能从数字 100 中减去 1，因为 100 - 1 = 99，99 比 1 的 10 倍（10）大。所以，数字 9 可以用 IX 来表示，但数字 100 不能用 IC 来表示，而是要用 XCIX（XC + IX，即 90 + 9 = 99）来表示。 总结第 i) 点和第 iii) 点，可以得到以下规则：符号 I 只能出现在符号 V 或 X 的前面（左边）；符号 X 只能出现在符号 L 或 C 的前面（左边）；符号 C 只能出现在符号 D 或 M 的前面（左边）。 规则 4如果在罗马数字上方加一条横线，表示将该数值乘以 1000，即原数的 1000 倍，如果上方有两条横线，表示的数字是原数的 1, 000, 000 倍。 如： $\overline{M}=1, 000, 000$ $\overline{V}=5, 000$ $\overline{\overline{X}} = 10, 000, 000 $ 练习尝试应用上述规则，写出以下阿拉伯数字对应的罗马数字35，65，99 求解过程如下：35 = 10 + 10 + 10 + 5，即 X + X + X + V（XXXV），所以 35 = XXXV；65 = 50 + 10 + 5，即 L + X + V（LXV），所以 65 = LXV；99 = （100 - 10）+（10 - 1），即 XC + IX（XCIX）所以 99 = XCIX 。]]></content>
      <categories>
        <category>数字与生活</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>罗马数字</tag>
      </tags>
  </entry>
</search>
